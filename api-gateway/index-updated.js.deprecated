/**
 * Production-Ready API Gateway with Service Discovery
 * 
 * Enhanced API Gateway with:
 * - Service discovery and registration
 * - Load balancing across service instances
 * - Circuit breaker integration
 * - JWT authentication middleware
 * - Rate limiting and security
 * - Comprehensive monitoring and tracing
 */

const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const jwt = require('jsonwebtoken');
const { v4: uuidv4 } = require('uuid');
const { ServiceClientFactory } = require('../../services/shared/service-client-factory');
const { ServiceRegistry } = require('../../services/shared/service-registry');
const { InterServiceAuth } = require('../../services/shared/inter-service-auth');
const { MetricsCollector } = require('../../services/shared/metrics');
const { createLogger } = require('../../services/shared/logger');

class EnhancedAPIGateway {
  constructor() {
    this.logger = createLogger('APIGateway');
    this.metrics = new MetricsCollector();
    this.port = process.env.GATEWAY_PORT || 3000;
    this.environment = process.env.NODE_ENV || 'development';
    
    // Initialize core components
    this.serviceRegistry = new ServiceRegistry(this.metrics, {
      healthCheckInterval: 30000,
      loadBalancingStrategy: 'round-robin'
    });
    
    this.interServiceAuth = new InterServiceAuth(this.metrics, {
      defaultTokenExpiration: 3600,
      enableTokenCaching: true
    });
    
    this.serviceClientFactory = new ServiceClientFactory(
      this.serviceRegistry,
      {
        getCorrelationId: () => this.getCorrelationId(),
        getCurrentTraceId: () => this.getCurrentTraceId(),
        createSpan: (name, context) => ({
          setTag: () => {},
          logEvent: () => {},
          logError: () => {},
          finish: () => {}
        }),
        startSpan: (name, context) => ({
          setTag: () => {},
          logEvent: () => {},
          logError: () => {},
          finish: () => {}
        })
      },
      this.metrics
    );

    // Gateway configuration
    this.config = {
      jwtSecret: process.env.JWT_SECRET || 'your-secret-key-change-in-production',
      rateLimitWindowMs: parseInt(process.env.RATE_LIMIT_WINDOW_MS) || 15 * 60 * 1000, // 15 minutes
      rateLimitMax: parseInt(process.env.RATE_LIMIT_MAX) || 1000,
      enableTracing: process.env.ENABLE_TRACING !== 'false',
      timeout: parseInt(process.env.GATEWAY_TIMEOUT) || 30000,
      retryAttempts: parseInt(process.env.GATEWAY_RETRY_ATTEMPTS) || 3
    };

    // Service routes configuration
    this.routes = new Map();
    this.app = null;
    this.server = null;
    
    this.initializeRoutes();
    this.setupMiddleware();
  }

  /**
   * Setup Express middleware
   */
  setupMiddleware() {
    // Security middleware
    this.app.use(helmet({
      contentSecurityPolicy: {
        directives: {
          defaultSrc: ["'self'"],
          styleSrc: ["'self'", "'unsafe-inline'"],
          scriptSrc: ["'self'"],
          imgSrc: ["'self'", "data:", "https:"],
        },
      },
      hsts: {
        maxAge: 31536000,
        includeSubDomains: true,
        preload: true
      }
    }));

    // CORS configuration
    this.app.use(cors({
      origin: this.getAllowedOrigins(),
      credentials: true,
      methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
      allowedHeaders: [
        'Origin', 'X-Requested-With', 'Content-Type', 
        'Accept', 'Authorization', 'X-Request-ID', 
        'X-Correlation-ID', 'X-Service-Token'
      ]
    }));

    // Rate limiting
    const limiter = rateLimit({
      windowMs: this.config.rateLimitWindowMs,
      max: this.config.rateLimitMax,
      message: {
        error: 'Too many requests',
        retryAfter: Math.ceil(this.config.rateLimitWindowMs / 1000)
      },
      standardHeaders: true,
      legacyHeaders: false,
      keyGenerator: (req) => {
        return req.ip || req.connection.remoteAddress || 'unknown';
      }
    });
    this.app.use(limiter);

    // Request parsing
    this.app.use(express.json({ limit: '10mb' }));
    this.app.use(express.urlencoded({ extended: true, limit: '10mb' }));

    // Request ID and correlation ID middleware
    this.app.use((req, res, next) => {
      req.requestId = req.headers['x-request-id'] || uuidv4();
      req.correlationId = req.headers['x-correlation-id'] || uuidv4();
      req.startTime = Date.now();

      res.setHeader('x-request-id', req.requestId);
      res.setHeader('x-correlation-id', req.correlationId);
      res.setHeader('x-service', 'api-gateway');

      // Log request
      this.logger.info('Incoming request', {
        requestId: req.requestId,
        correlationId: req.correlationId,
        method: req.method,
        url: req.url,
        ip: req.ip,
        userAgent: req.headers['user-agent']
      });

      next();
    });

    // Request timing middleware
    this.app.use((req, res, next) => {
      const originalSend = res.send;
      
      res.send = function(data) {
        const responseTime = Date.now() - req.startTime;
        
        // Log response
        this.logger.info('Request completed', {
          requestId: req.requestId,
          correlationId: req.correlationId,
          method: req.method,
          url: req.url,
          statusCode: res.statusCode,
          responseTime
        });

        // Record metrics
        this.metrics.recordHttpRequest(req.method, res.statusCode, responseTime);
        
        originalSend.call(this, data);
      }.bind(this);

      next();
    }.bind(this));

    // Error handling middleware
    this.app.use((error, req, res, next) => {
      this.logger.error('Request error', {
        requestId: req.requestId,
        correlationId: req.correlationId,
        method: req.method,
        url: req.url,
        error: error.message,
        stack: error.stack
      });

      this.metrics.recordError('gateway', error);

      res.status(500).json({
        error: 'Internal Server Error',
        requestId: req.requestId,
        correlationId: req.correlationId
      });
    });
  }

  /**
   * Initialize service routes
   */
  initializeRoutes() {
    this.app = express();

    // Health check
    this.app.get('/health', async (req, res) => {
      try {
        const health = await this.getGatewayHealth();
        res.json(health);
      } catch (error) {
        this.logger.error('Health check failed', { error: error.message });
        res.status(503).json({
          status: 'unhealthy',
          error: error.message
        });
      }
    });

    // Metrics endpoint
    this.app.get('/metrics', async (req, res) => {
      try {
        const metrics = await this.getGatewayMetrics();
        res.json(metrics);
      } catch (error) {
        this.logger.error('Metrics endpoint failed', { error: error.message });
        res.status(500).json({ error: error.message });
      }
    });

    // Service discovery endpoint (for admin)
    this.app.get('/admin/services', async (req, res) => {
      try {
        const services = await this.serviceRegistry.getAllServices();
        res.json(services);
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    });

    // Authentication routes (handled directly or forwarded)
    this.setupAuthRoutes();

    // Main API routes
    this.setupAPIRoutes();

    // Fallback route
    this.app.use('*', (req, res) => {
      res.status(404).json({
        error: 'Not Found',
        message: `Route ${req.method} ${req.url} not found`,
        requestId: req.requestId,
        correlationId: req.correlationId
      });
    });
  }

  /**
   * Setup authentication routes
   */
  setupAuthRoutes() {
    // User authentication
    this.app.post('/api/v1/auth/login', async (req, res) => {
      try {
        const response = await this.forwardRequest('auth-service', '/auth/login', {
          method: 'POST',
          body: req.body,
          headers: this.buildHeaders(req)
        });
        
        this.sendResponse(response, res);
      } catch (error) {
        this.handleError(error, res);
      }
    });

    // User registration
    this.app.post('/api/v1/auth/register', async (req, res) => {
      try {
        const response = await this.forwardRequest('auth-service', '/users', {
          method: 'POST',
          body: req.body,
          headers: this.buildHeaders(req)
        });
        
        this.sendResponse(response, res);
      } catch (error) {
        this.handleError(error, res);
      }
    });

    // Token validation
    this.app.post('/api/v1/auth/validate', async (req, res) => {
      try {
        const response = await this.forwardRequest('auth-service', '/auth/validate', {
          method: 'POST',
          body: req.body,
          headers: this.buildHeaders(req)
        });
        
        this.sendResponse(response, res);
      } catch (error) {
        this.handleError(error, res);
      }
    });

    // Company authentication
    this.app.post('/api/v1/auth/company/login', async (req, res) => {
      try {
        const response = await this.forwardRequest('auth-service', '/auth/company/login', {
          method: 'POST',
          body: req.body,
          headers: this.buildHeaders(req)
        });
        
        this.sendResponse(response, res);
      } catch (error) {
        this.handleError(error, res);
      }
    });

    // Company registration
    this.app.post('/api/v1/auth/company/register', async (req, res) => {
      try {
        const response = await this.forwardRequest('auth-service', '/companies', {
          method: 'POST',
          body: req.body,
          headers: this.buildHeaders(req)
        });
        
        this.sendResponse(response, res);
      } catch (error) {
        this.handleError(error, res);
      }
    });
  }

  /**
   * Setup main API routes
   */
  setupAPIRoutes() {
    // User service routes
    this.app.get('/api/v1/users/:userId', this.authenticate.bind(this), async (req, res) => {
      try {
        const response = await this.forwardRequest('user-service', `/profile/${req.params.userId}`, {
          method: 'GET',
          headers: this.buildHeaders(req)
        });
        
        this.sendResponse(response, res);
      } catch (error) {
        this.handleError(error, res);
      }
    });

    this.app.put('/api/v1/users/:userId', this.authenticate.bind(this), async (req, res) => {
      try {
        const response = await this.forwardRequest('user-service', `/profile/${req.params.userId}`, {
          method: 'PUT',
          body: req.body,
          headers: this.buildHeaders(req)
        });
        
        this.sendResponse(response, res);
      } catch (error) {
        this.handleError(error, res);
      }
    });

    this.app.get('/api/v1/users/search', async (req, res) => {
      try {
        const response = await this.forwardRequest('user-service', '/search', {
          method: 'GET',
          params: req.query,
          headers: this.buildHeaders(req)
        });
        
        this.sendResponse(response, res);
      } catch (error) {
        this.handleError(error, res);
      }
    });

    // Job service routes
    this.app.get('/api/v1/jobs', async (req, res) => {
      try {
        const response = await this.forwardRequest('job-service', '/jobs', {
          method: 'GET',
          params: req.query,
          headers: this.buildHeaders(req)
        });
        
        this.sendResponse(response, res);
      } catch (error) {
        this.handleError(error, res);
      }
    });

    this.app.get('/api/v1/jobs/:jobId', async (req, res) => {
      try {
        const response = await this.forwardRequest('job-service', `/jobs/${req.params.jobId}`, {
          method: 'GET',
          headers: this.buildHeaders(req)
        });
        
        this.sendResponse(response, res);
      } catch (error) {
        this.handleError(error, res);
      }
    });

    this.app.post('/api/v1/jobs', this.authenticate.bind(this), async (req, res) => {
      try {
        const response = await this.forwardRequest('job-service', '/jobs', {
          method: 'POST',
          body: req.body,
          headers: this.buildHeaders(req)
        });
        
        this.sendResponse(response, res);
      } catch (error) {
        this.handleError(error, res);
      }
    });

    this.app.post('/api/v1/jobs/:jobId/apply', this.authenticate.bind(this), async (req, res) => {
      try {
        const response = await this.forwardRequest('job-service', `/jobs/${req.params.jobId}/apply`, {
          method: 'POST',
          body: req.body,
          headers: this.buildHeaders(req)
        });
        
        this.sendResponse(response, res);
      } catch (error) {
        this.handleError(error, res);
      }
    });

    // Company service routes
    this.app.get('/api/v1/companies/:companyId', async (req, res) => {
      try {
        const response = await this.forwardRequest('company-service', `/companies/${req.params.companyId}`, {
          method: 'GET',
          headers: this.buildHeaders(req)
        });
        
        this.sendResponse(response, res);
      } catch (error) {
        this.handleError(error, res);
      }
    });

    this.app.put('/api/v1/companies/:companyId', this.authenticate.bind(this), async (req, res) => {
      try {
        const response = await this.forwardRequest('company-service', `/companies/${req.params.companyId}`, {
          method: 'PUT',
          body: req.body,
          headers: this.buildHeaders(req)
        });
        
        this.sendResponse(response, res);
      } catch (error) {
        this.handleError(error, res);
      }
    });

    this.app.get('/api/v1/companies/search', async (req, res) => {
      try {
        const response = await this.forwardRequest('company-service', '/companies/search', {
          method: 'GET',
          params: req.query,
          headers: this.buildHeaders(req)
        });
        
        this.sendResponse(response, res);
      } catch (error) {
        this.handleError(error, res);
      }
    });

    this.app.post('/api/v1/companies/:companyId/reviews', this.authenticate.bind(this), async (req, res) => {
      try {
        const response = await this.forwardRequest('company-service', `/companies/${req.params.companyId}/reviews`, {
          method: 'POST',
          body: req.body,
          headers: this.buildHeaders(req)
        });
        
        this.sendResponse(response, res);
      } catch (error) {
        this.handleError(error, res);
      }
    });
  }

  /**
   * Authentication middleware
   */
  async authenticate(req, res, next) {
    try {
      const authHeader = req.headers['authorization'];
      if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return res.status(401).json({
          error: 'Unauthorized',
          message: 'Authentication token required'
        });
      }

      const token = authHeader.substring(7);
      
      // Validate token with auth service
      const validationResponse = await this.forwardRequest('auth-service', '/auth/validate', {
        method: 'POST',
        body: { token },
        headers: {
          'x-service-token': await this.getServiceToken()
        }
      });

      if (!validationResponse.valid) {
        return res.status(401).json({
          error: 'Unauthorized',
          message: 'Invalid or expired token'
        });
      }

      // Add user info to request
      req.user = validationResponse.payload;
      next();

    } catch (error) {
      this.logger.error('Authentication error', { error: error.message });
      return res.status(500).json({
        error: 'Authentication failed',
        message: 'Internal server error'
      });
    }
  }

  /**
   * Forward request to service
   */
  async forwardRequest(serviceName, path, options = {}) {
    const startTime = Date.now();
    
    try {
      // Get service client
      const client = this.serviceClientFactory.createClient('api-gateway');
      
      // Forward request
      const response = await client.request(serviceName, {
        method: options.method || 'GET',
        path: path,
        body: options.body,
        params: options.params,
        headers: options.headers,
        timeout: this.config.timeout
      });

      const responseTime = Date.now() - startTime;
      
      this.logger.info('Request forwarded', {
        serviceName,
        path,
        method: options.method || 'GET',
        responseTime,
        status: response.status
      });

      return {
        status: response.status,
        data: response.data,
        headers: response.headers,
        responseTime
      };

    } catch (error) {
      const responseTime = Date.now() - startTime;
      
      this.logger.error('Request forwarding failed', {
        serviceName,
        path,
        error: error.message,
        responseTime
      });

      throw error;
    }
  }

  /**
   * Send response from service
   */
  sendResponse(serviceResponse, res) {
    // Copy headers
    if (serviceResponse.headers) {
      Object.entries(serviceResponse.headers).forEach(([key, value]) => {
        if (!key.startsWith('x-')) { // Don't copy internal headers
          res.setHeader(key, value);
        }
      });
    }

    // Set status and send data
    res.status(serviceResponse.status).json(serviceResponse.data);
  }

  /**
   * Handle forwarding errors
   */
  handleError(error, res) {
    this.logger.error('Request forwarding error', {
      error: error.message,
      stack: error.stack
    });

    if (error.status) {
      res.status(error.status).json({
        error: 'Service Error',
        message: error.message
      });
    } else {
      res.status(502).json({
        error: 'Bad Gateway',
        message: 'Service temporarily unavailable'
      });
    }
  }

  /**
   * Build headers for service requests
   */
  buildHeaders(req) {
    const headers = {
      'x-request-id': req.requestId,
      'x-correlation-id': req.correlationId,
      'x-forwarded-for': req.ip,
      'x-forwarded-proto': req.protocol,
      'x-forwarded-host': req.get('host')
    };

    // Add service token for inter-service communication
    if (req.user) {
      headers['x-user-id'] = req.user.userId || req.user.id;
      headers['x-user-email'] = req.user.email;
      headers['x-user-role'] = req.user.role;
    }

    // Add original authorization if service needs it
    if (req.headers['authorization']) {
      headers['x-original-authorization'] = req.headers['authorization'];
    }

    return headers;
  }

  /**
   * Get service token for inter-service communication
   */
  async getServiceToken() {
    try {
      const token = await this.interServiceAuth.generateToken('api-gateway', 'talentsphere-services');
      return token.token;
    } catch (error) {
      this.logger.error('Failed to get service token', { error: error.message });
      return null;
    }
  }

  /**
   * Get allowed origins for CORS
   */
  getAllowedOrigins() {
    const origins = process.env.ALLOWED_ORIGINS;
    if (origins) {
      return origins.split(',').map(origin => origin.trim());
    }
    
    if (this.environment === 'development') {
      return ['http://localhost:3000', 'http://localhost:3001'];
    }
    
    return ['https://talentsphere.com'];
  }

  /**
   * Get correlation ID for tracing
   */
  getCorrelationId() {
    return uuidv4();
  }

  /**
   * Get current trace ID
   */
  getCurrentTraceId() {
    return uuidv4();
  }

  /**
   * Get gateway health status
   */
  async getGatewayHealth() {
    const serviceHealth = await this.serviceRegistry.getRegistryStats();
    const authHealth = await this.interServiceAuth.getAuthStats();

    return {
      status: 'healthy',
      timestamp: new Date().toISOString(),
      services: serviceHealth,
      authentication: authHealth,
      uptime: process.uptime(),
      version: '1.0.0',
      environment: this.environment
    };
  }

  /**
   * Get gateway metrics
   */
  async getGatewayMetrics() {
    return {
      gateway: {
        requests: this.metrics.getHttpMetrics(),
        errors: this.metrics.getErrorMetrics(),
        uptime: process.uptime()
      },
      services: await this.serviceRegistry.getRegistryStats(),
      authentication: await this.interServiceAuth.getAuthStats()
    };
  }

  /**
   * Start the gateway
   */
  async start() {
    try {
      // Register services
      await this.registerServices();
      
      this.server = this.app.listen(this.port, () => {
        this.logger.info('ðŸŒ API Gateway started', {
          port: this.port,
          environment: this.environment,
          services: Array.from(this.routes.keys())
        });
        
        console.log(`ðŸŒ API Gateway running on port ${this.port}`);
        console.log(`ðŸ“ Environment: ${this.environment}`);
        console.log(`ðŸ”— Services registered: ${Array.from(this.routes.keys()).join(', ')}`);
        console.log(`ðŸ“Š Metrics: enabled`);
      });

    } catch (error) {
      this.logger.error('Failed to start API Gateway', { error: error.message });
      throw error;
    }
  }

  /**
   * Register services with the registry
   */
  async registerServices() {
    const services = [
      {
        serviceName: 'auth-service',
        url: `http://localhost:${process.env.AUTH_PORT || 3001}`,
        version: '1.0.0',
        region: 'local'
      },
      {
        serviceName: 'user-service',
        url: `http://localhost:${process.env.USER_PORT || 3002}`,
        version: '1.0.0',
        region: 'local'
      },
      {
        serviceName: 'job-service',
        url: `http://localhost:${process.env.JOB_PORT || 3003}`,
        version: '1.0.0',
        region: 'local'
      },
      {
        serviceName: 'company-service',
        url: `http://localhost:${process.env.COMPANY_PORT || 3004}`,
        version: '1.0.0',
        region: 'local'
      }
    ];

    for (const service of services) {
      await this.serviceRegistry.registerService(service);
      this.routes.set(service.serviceName, service);
    }

    this.logger.info('Services registered with registry', {
      count: services.length,
      services: services.map(s => s.serviceName)
    });
  }

  /**
   * Graceful shutdown
   */
  async stop() {
    this.logger.info('Shutting down API Gateway...');

    try {
      if (this.server) {
        await new Promise((resolve) => {
          this.server.close(resolve);
        });
      }

      await this.serviceRegistry.shutdown();
      await this.interServiceAuth.shutdown();

      this.logger.info('API Gateway shutdown complete');
      
    } catch (error) {
      this.logger.error('Error during shutdown', { error: error.message });
    }
  }
}

module.exports = EnhancedAPIGateway;

// Auto-start if this is the main module
if (require.main === module) {
  const gateway = new EnhancedAPIGateway();

  gateway.start().catch(console.error);

  // Graceful shutdown handlers
  process.on('SIGTERM', async () => {
    console.log('ðŸ›‘ SIGTERM received, shutting down gracefully...');
    await gateway.stop();
    process.exit(0);
  });

  process.on('SIGINT', async () => {
    console.log('ðŸ›‘ SIGINT received, shutting down gracefully...');
    await gateway.stop();
    process.exit(0);
  });
}